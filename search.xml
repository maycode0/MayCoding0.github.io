<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>KMP算法学习</title>
    <url>/2025/02/07/KMP/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP串匹配算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL记录</title>
    <url>/2025/03/04/STL/</url>
    <content><![CDATA[<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p>C++ STL（标准模板库）中最常用的容器包括：</p>
<ol>
<li><strong>vector</strong><ul>
<li>动态数组，支持随机访问，尾部插入和删除高效。</li>
<li>适用场景：需要频繁随机访问且尾部操作较多的情况。</li>
</ul>
</li>
<li><strong>list</strong><ul>
<li>双向链表，插入和删除高效，但不支持随机访问。</li>
<li>适用场景：频繁在任意位置插入或删除元素。</li>
</ul>
</li>
<li><strong>deque</strong><ul>
<li>双端队列，支持头部和尾部的高效插入与删除，允许随机访问。</li>
<li>适用场景：需要在两端频繁操作且偶尔随机访问。</li>
</ul>
</li>
<li><strong>stack栈</strong><ul>
<li>后进先出（LIFO）容器，基于deque或list实现。</li>
<li>适用场景：需要后进先出逻辑，如函数调用栈。</li>
</ul>
</li>
<li><strong>queue队列</strong><ul>
<li>先进先出（FIFO）容器，基于deque或list实现。</li>
<li>适用场景：需要先进先出逻辑，如任务调度。</li>
</ul>
</li>
<li><strong>priority_queue</strong><ul>
<li>优先队列，基于堆实现，元素按优先级排序。</li>
<li>适用场景：需要按优先级处理元素，如任务调度。</li>
</ul>
</li>
<li><strong>set</strong><ul>
<li>有序集合，元素唯一且自动排序，基于红黑树实现。</li>
<li>适用场景：需要有序且唯一的元素集合。</li>
</ul>
</li>
<li><strong>multiset</strong><ul>
<li>允许重复元素的有序集合，基于红黑树实现。</li>
<li>适用场景：需要有序但允许重复的元素集合。</li>
</ul>
</li>
<li><strong>map</strong><ul>
<li>有序键值对容器，键唯一且自动排序，基于红黑树实现。</li>
<li>适用场景：需要键值对且键唯一的有序集合。</li>
</ul>
</li>
<li><strong>multimap</strong><ul>
<li>允许重复键的有序键值对容器，基于红黑树实现。</li>
<li>适用场景：需要键值对但允许键重复的有序集合。</li>
</ul>
</li>
<li><strong>unordered_set</strong><ul>
<li>无序集合，元素唯一，基于哈希表实现。</li>
<li>适用场景：需要快速查找且不关心顺序的唯一元素集合。</li>
</ul>
</li>
<li><strong>unordered_multiset</strong><ul>
<li>允许重复元素的无序集合，基于哈希表实现。</li>
<li>适用场景：需要快速查找且允许重复的无序元素集合。</li>
</ul>
</li>
<li><strong>unordered_map</strong><ul>
<li>无序键值对容器，键唯一，基于哈希表实现。</li>
<li>适用场景：需要快速查找且不关心顺序的键值对集合。</li>
</ul>
</li>
<li><strong>unordered_multimap</strong><ul>
<li>允许重复键的无序键值对容器，基于哈希表实现。</li>
<li>适用场景：需要快速查找且允许键重复的无序键值对集合。</li>
</ul>
</li>
</ol>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>初始化方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec1; <span class="comment">// 空的 vector</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec2</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">//  5 个初始值为 0</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;<span class="comment">//包含 5 个元素,初始值为 10</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec4 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">//初始化列表</span></span><br></pre></td></tr></table></figure>

<p><code>.reserve()</code>与 <code>.resize()方法</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>); <span class="comment">// 仅仅预留空间大小，若用[]访问会访问野空间，使用at访问则会抛出异常</span></span><br><span class="line">std::cout&lt;&lt;vec.<span class="built_in">capacity</span>()&lt;&lt;std::endl;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;vec.<span class="built_in">at</span>(<span class="number">0</span>)&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> std::exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">// 此时分配的空间是实打实的空间，全部初始化为0</span></span><br><span class="line">std::cout&lt;&lt;vec.<span class="built_in">at</span>(<span class="number">0</span>)&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure>

<p>添加元素&#x2F;删除元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">10</span>);<span class="comment">// 在尾部添加元素</span></span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">40</span>);<span class="comment">// 使用 emplace_back 直接构造元素</span></span><br><span class="line">vec.<span class="built_in">pop_back</span>();<span class="comment">// 删除最后一个元素</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">// 删除指定位置的元素（删除第 2 个元素）</span></span><br></pre></td></tr></table></figure>

<p>访问方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Element at index 2: &quot;</span> &lt;&lt; vec[<span class="number">2</span>] &lt;&lt; std::endl;<span class="comment">// 使用下标访问元素  </span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Element at index 3: &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">3</span>) &lt;&lt; std::endl;<span class="comment">// 使用 at() 访问元素（会检查边界）  </span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; vec.<span class="built_in">front</span>() &lt;&lt; std::endl;<span class="comment">// 访问第一个</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; vec.<span class="built_in">back</span>() &lt;&lt; std::endl;<span class="comment">//最后一个元素</span></span><br></pre></td></tr></table></figure>

<p>遍历方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">// 使用下标遍历  </span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Using range-based for loop: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : vec) &#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;  <span class="comment">// 使用范围 for 循环遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;<span class="comment">// 使用迭代器遍历</span></span><br></pre></td></tr></table></figure>

<p>排序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());    <span class="comment">// 对 vector 进行升序排序</span></span><br></pre></td></tr></table></figure>

<p>交换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">vec<span class="number">1.</span><span class="built_in">swap</span>(vec2);</span><br></pre></td></tr></table></figure>

<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>初始化与vector保持一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">初始化与vector保持一致。</span><br></pre></td></tr></table></figure>

<p>添加元素<br><code>.push_back()</code>在尾部添加元素，<code>.push_front()</code>在头部添加元素。</p>
<p>访问元素</p>
<p><code>.front()</code>访问头 <code>.back()</code>访问尾。</p>
<p>删除</p>
<p><code>.pop_front()</code>删除头部元素 <code>.pop_back()</code>删除尾部元素。</p>
<p>成员函数</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>push_back</code></th>
<th><code>emplace_back</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>临时对象</strong></td>
<td>需要创建临时对象</td>
<td>不需要创建临时对象</td>
</tr>
<tr>
<td><strong>拷贝&#x2F;移动操作</strong></td>
<td>可能涉及拷贝或移动操作</td>
<td>无拷贝或移动操作</td>
</tr>
<tr>
<td><strong>多参数构造</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较低（涉及额外开销）</td>
<td>较高（直接构造）</td>
</tr>
<tr>
<td><strong>代码简洁性</strong></td>
<td>需要显式构造对象</td>
<td>直接传递构造参数</td>
</tr>
</tbody></table>
<p>因此，在大多数情况下，推荐使用 <code>emplace_back</code>，尤其是在需要高效构造对象或传递多个构造参数的场景中。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++学习路线</title>
    <url>/2025/02/27/cpp_stage/</url>
    <content><![CDATA[<h3 id="一、基础阶段（1-3个月）"><a href="#一、基础阶段（1-3个月）" class="headerlink" title="一、基础阶段（1-3个月）"></a><strong>一、基础阶段（1-3个月）</strong></h3><h4 id="目标：掌握C-核心语法与编程思想，写出健壮的面向过程代码"><a href="#目标：掌握C-核心语法与编程思想，写出健壮的面向过程代码" class="headerlink" title="目标：掌握C++核心语法与编程思想，写出健壮的面向过程代码"></a><strong>目标</strong>：掌握C++核心语法与编程思想，写出健壮的面向过程代码</h4><ol>
<li><strong>语法基础</strong><ul>
<li><strong>数据类型、运算符、控制流（if&#x2F;for&#x2F;while）</strong></li>
<li><strong>函数：参数传递（值&#x2F;指针&#x2F;引用）、函数重载</strong></li>
<li><strong>数组、字符串（C风格字符串与</strong> <code>std::string</code>）</li>
<li><strong>结构体、枚举、联合体</strong></li>
<li><strong>关键练习</strong>：实现计算器、学生成绩管理系统</li>
</ul>
</li>
<li><strong>内存管理</strong><ul>
<li><strong>堆与栈的区别、</strong><code>new</code>&#x2F;<code>delete</code>操作</li>
<li><strong>指针与引用的本质区别</strong></li>
<li><strong>动态数组（</strong><code>new int[n]</code>）与内存泄漏检测工具（Valgrind）</li>
<li><strong>关键练习</strong>：实现自定义动态数组类（模拟 <code>std::vector</code>雏形）</li>
</ul>
</li>
<li><strong>面向对象（OOP）</strong><ul>
<li><strong>类与对象：封装、构造&#x2F;析构函数</strong></li>
<li><strong>继承与多态：虚函数、抽象类</strong></li>
<li><strong>运算符重载（</strong><code>+</code>, <code>&lt;&lt;</code>等）</li>
<li><strong>关键练习</strong>：设计图形类层次（Shape→Circle&#x2F;Rectangle）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、进阶阶段（3-6个月）"><a href="#二、进阶阶段（3-6个月）" class="headerlink" title="二、进阶阶段（3-6个月）"></a><strong>二、进阶阶段（3-6个月）</strong></h3><h4 id="目标：深入理解C-标准库与现代特性，掌握工程级代码规范"><a href="#目标：深入理解C-标准库与现代特性，掌握工程级代码规范" class="headerlink" title="目标：深入理解C++标准库与现代特性，掌握工程级代码规范"></a><strong>目标</strong>：深入理解C++标准库与现代特性，掌握工程级代码规范</h4><ol>
<li><strong>标准库（STL）</strong><ul>
<li><strong>容器：</strong><code>vector</code>&#x2F;<code>list</code>&#x2F;<code>map</code>&#x2F;<code>unordered_map</code></li>
<li><strong>算法：</strong><code>sort</code>&#x2F;<code>find</code>&#x2F;<code>transform</code></li>
<li><strong>迭代器与仿函数（函数对象）</strong></li>
<li><strong>关键练习</strong>：统计文本词频（<code>map</code>+文件操作）</li>
</ul>
</li>
<li><strong>模板与泛型编程</strong><ul>
<li><strong>函数模板与类模板</strong></li>
<li><strong>模板特化与偏特化</strong></li>
<li><strong>关键练习</strong>：实现泛型排序算法（支持自定义比较）</li>
</ul>
</li>
<li><strong>现代C++（C++11&#x2F;14&#x2F;17）</strong><ul>
<li><strong>智能指针：</strong><code>unique_ptr</code>&#x2F;<code>shared_ptr</code></li>
<li><strong>右值引用与移动语义</strong></li>
<li><strong>Lambda表达式、范围for循环</strong></li>
<li><strong>关键练习</strong>：重构旧代码，用智能指针替代裸指针</li>
</ul>
</li>
<li><strong>异常处理与RAII</strong><ul>
<li><code>try</code>&#x2F;<code>catch</code>机制</li>
<li><strong>资源获取即初始化（RAII）模式</strong></li>
<li><strong>关键练习</strong>：实现文件自动关闭类（利用析构函数）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、高阶阶段（6-12个月）"><a href="#三、高阶阶段（6-12个月）" class="headerlink" title="三、高阶阶段（6-12个月）"></a><strong>三、高阶阶段（6-12个月）</strong></h3><h4 id="目标：掌握系统级编程与性能优化，深入特定领域"><a href="#目标：掌握系统级编程与性能优化，深入特定领域" class="headerlink" title="目标：掌握系统级编程与性能优化，深入特定领域"></a><strong>目标</strong>：掌握系统级编程与性能优化，深入特定领域</h4><ol>
<li><strong>多线程与并发</strong><ul>
<li><code>std::thread</code>、<code>std::async</code></li>
<li><strong>互斥锁（</strong><code>mutex</code>）、条件变量（<code>condition_variable</code>）</li>
<li><strong>原子操作（</strong><code>atomic</code>）与无锁编程</li>
<li><strong>关键练习</strong>：实现生产者-消费者模型</li>
</ul>
</li>
<li><strong>系统编程</strong><ul>
<li><strong>文件系统操作（</strong><code>&lt;filesystem&gt;</code>）</li>
<li><strong>网络编程（Socket、Boost.Asio库）</strong></li>
<li><strong>内存对齐与缓存优化</strong></li>
<li><strong>关键练习</strong>：实现简易HTTP服务器</li>
</ul>
</li>
<li><strong>模板元编程与编译期计算</strong><ul>
<li><strong>类型萃取（Type Traits）</strong></li>
<li><strong>SFINAE与</strong> <code>constexpr</code></li>
<li><strong>关键练习</strong>：实现编译期斐波那契数列计算</li>
</ul>
</li>
<li><strong>领域深入（选择1-2个方向）</strong><ul>
<li><strong>游戏开发</strong>：Unreal Engine C++、OpenGL&#x2F;DirectX</li>
<li><strong>高频交易</strong>：低延迟优化、锁无关数据结构</li>
<li><strong>嵌入式</strong>：RTOS、硬件寄存器操作</li>
<li><strong>开源贡献</strong>：参与LLVM&#x2F;Clang、Chromium等项目</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、工程化实践"><a href="#四、工程化实践" class="headerlink" title="四、工程化实践"></a><strong>四、工程化实践</strong></h3><ol>
<li><strong>构建工具</strong><ul>
<li><strong>CMake编写跨平台构建脚本</strong></li>
<li><strong>包管理：vcpkg&#x2F;conan</strong></li>
</ul>
</li>
<li><strong>调试与性能分析</strong><ul>
<li><strong>GDB&#x2F;LLDB调试核心转储（Core Dump）</strong></li>
<li><strong>性能剖析工具：perf、gprof、VTune</strong></li>
</ul>
</li>
<li><strong>代码质量</strong><ul>
<li><strong>静态分析：Clang-Tidy、Cppcheck</strong></li>
<li><strong>单元测试：Google Test框架</strong></li>
<li><strong>代码规范：Google C++ Style Guide</strong></li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、学习资源推荐"><a href="#五、学习资源推荐" class="headerlink" title="五、学习资源推荐"></a><strong>五、学习资源推荐</strong></h3><h4 id="书籍（按难度排序）："><a href="#书籍（按难度排序）：" class="headerlink" title="书籍（按难度排序）："></a><strong>书籍</strong>（按难度排序）：</h4><ol>
<li><strong>入门</strong>：《C++ Primer》《Accelerated C++》</li>
<li><strong>进阶</strong>：《Effective C++》《Effective Modern C++》</li>
<li><strong>高阶</strong>：《C++ Concurrency in Action》《Template Metaprogramming》</li>
</ol>
<h4 id="在线课程："><a href="#在线课程：" class="headerlink" title="在线课程："></a><strong>在线课程</strong>：</h4><ul>
<li><strong>Coursera：北大《程序设计与算法》</strong></li>
<li><strong>Udemy：Beginning C++ Programming - From Beginner to Beyond</strong></li>
</ul>
<h4 id="开源项目："><a href="#开源项目：" class="headerlink" title="开源项目："></a><strong>开源项目</strong>：</h4><ul>
<li>入门级： <a href="https://github.com/qinguoyi/TinyWebServer">TinyWebServer</a>（学习网络编程）</li>
<li>进阶级： <a href="https://github.com/fmtlib/fmt">fmtlib</a>（学习现代C++库设计）</li>
</ul>
<hr>
<h3 id="六、项目实战建议"><a href="#六、项目实战建议" class="headerlink" title="六、项目实战建议"></a><strong>六、项目实战建议</strong></h3><table>
<thead>
<tr>
<th><strong>阶段</strong></th>
<th><strong>项目示例</strong></th>
<th><strong>技术要点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>初级</strong></td>
<td><strong>命令行日记本</strong></td>
<td><strong>文件操作、OOP设计</strong></td>
</tr>
<tr>
<td><strong>中级</strong></td>
<td><strong>多线程日志库</strong></td>
<td><strong>线程安全、RAII、性能优化</strong></td>
</tr>
<tr>
<td><strong>高级</strong></td>
<td><strong>简易数据库引擎（LSM-Tree实现）</strong></td>
<td><strong>磁盘IO、内存管理、并发控制</strong></td>
</tr>
</tbody></table>
<hr>
<h3 id="七、求职与职业发展"><a href="#七、求职与职业发展" class="headerlink" title="七、求职与职业发展"></a><strong>七、求职与职业发展</strong></h3><ol>
<li><strong>简历重点</strong>：<ul>
<li><strong>突出高性能&#x2F;高并发项目经验</strong></li>
<li><strong>展示对内存管理与多线程的深刻理解</strong></li>
</ul>
</li>
<li><strong>面试高频考点</strong>：<ul>
<li><strong>虚函数表（vtable）实现原理</strong></li>
<li><code>std::vector</code>扩容机制</li>
<li><strong>智能指针循环引用问题</strong></li>
<li><strong>多线程死锁场景分析</strong></li>
</ul>
</li>
<li><strong>职业路径</strong>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初级C++开发 → 系统架构师/游戏引擎工程师 → 技术专家（特定领域）</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a><strong>避坑指南</strong></h3><ol>
<li><strong>避免过早优化</strong>：先保证正确性，再考虑性能（“Make it work, make it right, make it fast”）</li>
<li><strong>慎用裸指针</strong>：优先使用智能指针和RAII管理资源</li>
<li><strong>关注C++标准演进</strong>：C++20&#x2F;23的Module、Coroutine等新特性</li>
</ol>
]]></content>
      <categories>
        <category>学习路线</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello CMAKE</title>
    <url>/2025/02/27/cmake/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>默认标签</category>
      </categories>
      <tags>
        <tag>默认标签</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello C++</title>
    <url>/2025/02/07/hello-cpp/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>C/C++环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql聚合查询</title>
    <url>/2025/03/02/groupby/</url>
    <content><![CDATA[<h3 id="1-基础聚合函数"><a href="#1-基础聚合函数" class="headerlink" title="1. 基础聚合函数"></a><strong>1. 基础聚合函数</strong></h3><h4 id="1-COUNT：统计行数"><a href="#1-COUNT：统计行数" class="headerlink" title="(1) COUNT：统计行数"></a>(1) <strong><code>COUNT</code></strong>：统计行数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计所有员工数量</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> total_employees <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 统计有部门的员工数量（排除 NULL）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(department_id) <span class="keyword">AS</span> employees_with_dept <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="2-SUM：求和"><a href="#2-SUM：求和" class="headerlink" title="(2) SUM：求和"></a>(2) <strong><code>SUM</code></strong>：求和</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算所有订单的总金额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_amount <span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>

<h4 id="3-AVG：求平均值"><a href="#3-AVG：求平均值" class="headerlink" title="(3) AVG：求平均值"></a>(3) <strong><code>AVG</code></strong>：求平均值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 计算员工的平均工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">AS</span> avg_salary <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="4-MAX-MIN：最大值-最小值"><a href="#4-MAX-MIN：最大值-最小值" class="headerlink" title="(4) MAX&#x2F;MIN：最大值&#x2F;最小值"></a>(4) <strong><code>MAX</code>&#x2F;<code>MIN</code></strong>：最大值&#x2F;最小值</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 找最高和最低工资</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(salary) <span class="keyword">AS</span> max_salary, <span class="built_in">MIN</span>(salary) <span class="keyword">AS</span> min_salary <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-GROUP-BY：分组聚合"><a href="#2-GROUP-BY：分组聚合" class="headerlink" title="2. GROUP BY：分组聚合"></a><strong>2. <code>GROUP BY</code>：分组聚合</strong></h3><h4 id="示例表结构"><a href="#示例表结构" class="headerlink" title="示例表结构"></a>示例表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> sales (</span><br><span class="line">    product_id <span class="type">INT</span>,</span><br><span class="line">    category <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    sale_date <span class="type">DATE</span>,</span><br><span class="line">    amount <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> sales <span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;2023-01-01&#x27;</span>, <span class="number">1000</span>),</span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Electronics&#x27;</span>, <span class="string">&#x27;2023-01-02&#x27;</span>, <span class="number">1500</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Clothing&#x27;</span>, <span class="string">&#x27;2023-01-01&#x27;</span>, <span class="number">500</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Clothing&#x27;</span>, <span class="string">&#x27;2023-01-02&#x27;</span>, <span class="number">800</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询示例"><a href="#查询示例" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按商品类别统计总销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> category, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>category</th>
<th>total_sales</th>
</tr>
</thead>
<tbody><tr>
<td>Electronics</td>
<td>2500.00</td>
</tr>
<tr>
<td>Clothing</td>
<td>1300.00</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-HAVING：过滤分组结果"><a href="#3-HAVING：过滤分组结果" class="headerlink" title="3. HAVING：过滤分组结果"></a><strong>3. <code>HAVING</code>：过滤分组结果</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 筛选总销售额超过 2000 的类别</span></span><br><span class="line"><span class="keyword">SELECT</span> category, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category</span><br><span class="line"><span class="keyword">HAVING</span> total_sales <span class="operator">&gt;</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>

<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>category</th>
<th>total_sales</th>
</tr>
</thead>
<tbody><tr>
<td>Electronics</td>
<td>2500.00</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-多字段分组"><a href="#4-多字段分组" class="headerlink" title="4. 多字段分组"></a><strong>4. 多字段分组</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按商品 ID 和日期统计销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> product_id, sale_date, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> daily_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> product_id, sale_date;</span><br></pre></td></tr></table></figure>

<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>product_id</th>
<th>sale_date</th>
<th>daily_sales</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2023-01-01</td>
<td>1000.00</td>
</tr>
<tr>
<td>1</td>
<td>2023-01-02</td>
<td>1500.00</td>
</tr>
<tr>
<td>2</td>
<td>2023-01-01</td>
<td>500.00</td>
</tr>
<tr>
<td>2</td>
<td>2023-01-02</td>
<td>800.00</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-WITH-ROLLUP：生成小计和总计"><a href="#5-WITH-ROLLUP：生成小计和总计" class="headerlink" title="5. WITH ROLLUP：生成小计和总计"></a><strong>5. <code>WITH ROLLUP</code>：生成小计和总计</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按类别和商品 ID 统计销售额，并生成小计和总计</span></span><br><span class="line"><span class="keyword">SELECT</span> category, product_id, <span class="built_in">SUM</span>(amount) <span class="keyword">AS</span> total_sales</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category, product_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>category</th>
<th>product_id</th>
<th>total_sales</th>
</tr>
</thead>
<tbody><tr>
<td>Clothing</td>
<td>2</td>
<td>1300.00</td>
</tr>
<tr>
<td>Clothing</td>
<td>NULL</td>
<td>1300.00</td>
</tr>
<tr>
<td>Electronics</td>
<td>1</td>
<td>2500.00</td>
</tr>
<tr>
<td>Electronics</td>
<td>NULL</td>
<td>2500.00</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>3800.00</td>
</tr>
</tbody></table>
<hr>
<h3 id="6-聚合函数结合条件"><a href="#6-聚合函数结合条件" class="headerlink" title="6. 聚合函数结合条件"></a><strong>6. 聚合函数结合条件</strong></h3><h4 id="1-CASE-WHEN-实现条件聚合"><a href="#1-CASE-WHEN-实现条件聚合" class="headerlink" title="(1) CASE WHEN 实现条件聚合"></a>(1) <strong><code>CASE WHEN</code> 实现条件聚合</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计 2023-01-01 和 2023-01-02 的销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2023-01-01&#x27;</span> <span class="keyword">THEN</span> amount <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> sales_day1,</span><br><span class="line">    <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2023-01-02&#x27;</span> <span class="keyword">THEN</span> amount <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> sales_day2</span><br><span class="line"><span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>

<h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>sales_day1</th>
<th>sales_day2</th>
</tr>
</thead>
<tbody><tr>
<td>1500.00</td>
<td>2300.00</td>
</tr>
</tbody></table>
<h4 id="2-IF-函数简化条件"><a href="#2-IF-函数简化条件" class="headerlink" title="(2) IF 函数简化条件"></a>(2) <strong><code>IF</code> 函数简化条件</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计高价商品（金额 &gt; 1000）的销售额</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(IF(amount <span class="operator">&gt;</span> <span class="number">1000</span>, amount, <span class="number">0</span>)) <span class="keyword">AS</span> high_value_sales <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-聚合函数与去重"><a href="#7-聚合函数与去重" class="headerlink" title="7. 聚合函数与去重"></a><strong>7. 聚合函数与去重</strong></h3><h4 id="使用-DISTINCT"><a href="#使用-DISTINCT" class="headerlink" title="使用 DISTINCT"></a>使用 <code>DISTINCT</code></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 统计不同商品的销售次数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> product_id) <span class="keyword">AS</span> unique_products <span class="keyword">FROM</span> sales;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong><code>GROUP BY</code> 与非聚合字段</strong><br>SELECT 中的非聚合字段必须出现在 <code>GROUP BY</code> 中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 正确写法</span></span><br><span class="line"><span class="keyword">SELECT</span> category, product_id, <span class="built_in">SUM</span>(amount)</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category, product_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误写法（product_id 未在 GROUP BY 中）</span></span><br><span class="line"><span class="keyword">SELECT</span> category, product_id, <span class="built_in">SUM</span>(amount)</span><br><span class="line"><span class="keyword">FROM</span> sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> category;</span><br></pre></td></tr></table></figure></li>
<li><p><strong><code>HAVING</code> 与 <code>WHERE</code> 的区别</strong></p>
<ul>
<li><code>WHERE</code> 在聚合前过滤行。</li>
<li><code>HAVING</code> 在聚合后过滤分组。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>聚合查询的核心用途：</p>
<ul>
<li>统计汇总数据（如总数、总和、平均值）。</li>
<li>按维度（如时间、类别）分组分析。</li>
<li>过滤聚合结果（如筛选销售额超过阈值的分组）。</li>
</ul>
<p>通过灵活组合聚合函数、<code>GROUP BY</code> 和 <code>HAVING</code>，可以高效实现复杂的数据分析需求。</p>
<h1 id="力扣已刷相关题"><a href="#力扣已刷相关题" class="headerlink" title="力扣已刷相关题"></a>力扣已刷相关题</h1><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>表: <code>Person</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| id          | int     |</span><br><span class="line">| email       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">id 是该表的主键（具有唯一值的列）。</span><br><span class="line">此表的每一行都包含一封电子邮件。电子邮件不包含大写字母。</span><br></pre></td></tr></table></figure>

<p>编写解决方案来报告所有重复的电子邮件。 请注意，可以保证电子邮件字段不为 NULL。</p>
<p>以 **任意顺序 **返回结果表。</p>
<p>结果格式如下例。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 
Person 表:
+----+---------+
| id | email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
<strong>输出:</strong> 
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
<strong>解释:</strong> a@b.com 出现了两次。</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> email <span class="keyword">as</span> Email</span><br><span class="line"><span class="keyword">from</span> Person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> email</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(email) <span class="operator">&gt;</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="题目：511-游戏玩法分析I"><a href="#题目：511-游戏玩法分析I" class="headerlink" title="题目：511.游戏玩法分析I"></a>题目：511.游戏玩法分析I</h2><p>活动表 <code>Activity</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| player_id    | int     |</span><br><span class="line">| device_id    | int     |</span><br><span class="line">| event_date   | date    |</span><br><span class="line">| games_played | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">在 SQL 中，表的主键是 (player_id, event_date)。</span><br><span class="line">这张表展示了一些游戏玩家在游戏平台上的行为活动。</span><br><span class="line">每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。</span><br></pre></td></tr></table></figure>

<p>查询每位玩家 <strong>第一次登录平台的日期</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> player_id, <span class="built_in">min</span>(event_date) <span class="keyword">as</span> first_login</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> player_id</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2025/02/06/hello-world/</url>
    <content><![CDATA[<p>记录Hexo搭建博客使用基本命令与操作。</p>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<h3 id="Generate"><a href="#Generate" class="headerlink" title="Generate"></a>Generate</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>

<p>启动服务器。 默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>-p, –port</td>
<td>重设端口</td>
</tr>
<tr>
<td>-s, –static</td>
<td>只使用静态文件</td>
</tr>
<tr>
<td>-l, –log</td>
<td>启用日志Override logger format.</td>
</tr>
</tbody></table>
<h3 id="Newhexo-new-page-–path-about-me-“About-me”"><a href="#Newhexo-new-page-–path-about-me-“About-me”" class="headerlink" title="Newhexo new page –path about&#x2F;me “About me”"></a>Newhexo new page –path about&#x2F;me “About me”</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page --path about/me <span class="string">&quot;About me&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter中title 为 <code>&quot;About me&quot;</code></p>
<h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<p>推送至github远程仓库。</p>
<h2 id="Front-Matter"><a href="#Front-Matter" class="headerlink" title="Front Matter"></a>Front Matter</h2><table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
</tr>
<tr>
<td>description</td>
<td>文章描述</td>
</tr>
<tr>
<td>tags</td>
<td>标签</td>
</tr>
<tr>
<td>categories</td>
<td>分类</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式如下</span><br><span class="line">title: Hello Hexo</span><br><span class="line">description: 记录Hexo搭建博客使用操作。</span><br><span class="line">categories:</span><br><span class="line">  - Hello</span><br><span class="line">tags:</span><br><span class="line">  - Hexo入门</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>Hexo入门</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello deepseek</title>
    <url>/2025/02/07/init_deepseek/</url>
    <content><![CDATA[<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-下载ollama"><a href="#1-下载ollama" class="headerlink" title="1. 下载ollama"></a>1. 下载ollama</h3><p>官网地址：<a href="https://ollama.com/">Ollama</a></p>
<blockquote>
<p>Ollama：是一个开源框架，用户可以使用Ollama在计算机本地创建语言模型。简单的说就是使用它可以在你自己的电脑上创建类似ChatGpt或者kimi那样的AI大模型应用。并且还可以自己训、微调你的大模型，让他为你干活。</p>
</blockquote>
<h3 id="2-修改model下载路径"><a href="#2-修改model下载路径" class="headerlink" title="2. 修改model下载路径"></a>2. 修改model下载路径</h3><p>新建系统变量：OLLAMA_MODELS，并选定合适位置。</p>
<h3 id="3-下载合适model"><a href="#3-下载合适model" class="headerlink" title="3. 下载合适model"></a>3. 下载合适model</h3><p>在该页面<a href="https://ollama.com/library/deepseek-r1">deepseek-r1</a>选择合适model，复制命令，如 <code>ollama run deepseek-r1:14b </code>，打开cmd开始下载。</p>
<h3 id="4-选择合适图形化界面"><a href="#4-选择合适图形化界面" class="headerlink" title="4. 选择合适图形化界面"></a>4. 选择合适图形化界面</h3><p>这里选择<a href="https://chatboxai.app/zh">Chatbox</a>，进入app后选择ollama api，随后按选项自定义即可。</p>
<h3 id="5-Cherry-Studio-API配置"><a href="#5-Cherry-Studio-API配置" class="headerlink" title="5. Cherry Studio API配置"></a>5. Cherry Studio API配置</h3><p>API配置更加适合本地部署不占用内存，在官网申请免费的api即可。</p>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>deepseek-r1本地部署</tag>
        <tag>AI大模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello markdown</title>
    <url>/2025/02/07/markdown/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>markdown入门</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 连接查询</title>
    <url>/2025/03/02/mysql_join_connect/</url>
    <content><![CDATA[<h3 id="1-内连接（INNER-JOIN）"><a href="#1-内连接（INNER-JOIN）" class="headerlink" title="1. 内连接（INNER JOIN）"></a>1. <strong>内连接（INNER JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回两个表中匹配的行。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="2-左连接（LEFT-JOIN）"><a href="#2-左连接（LEFT-JOIN）" class="headerlink" title="2. 左连接（LEFT JOIN）"></a>2. <strong>左连接（LEFT JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回左表所有行，右表无匹配时填充 <code>NULL</code>。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-右连接（RIGHT-JOIN）"><a href="#3-右连接（RIGHT-JOIN）" class="headerlink" title="3. 右连接（RIGHT JOIN）"></a>3. <strong>右连接（RIGHT JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回右表所有行，左表无匹配时填充 <code>NULL</code>。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1.</span>列 <span class="operator">=</span> 表<span class="number">2.</span>列;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-全外连接（FULL-OUTER-JOIN）"><a href="#4-全外连接（FULL-OUTER-JOIN）" class="headerlink" title="4. 全外连接（FULL OUTER JOIN）"></a>4. <strong>全外连接（FULL OUTER JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回两表所有行，无匹配时填充 <code>NULL</code>（MySQL需用 <code>UNION</code>模拟）。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> 列 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 条件;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount <span class="keyword">FROM</span> users <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> users.name, orders.amount <span class="keyword">FROM</span> users <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> orders <span class="keyword">ON</span> users.id <span class="operator">=</span> orders.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="5-交叉连接（CROSS-JOIN）"><a href="#5-交叉连接（CROSS-JOIN）" class="headerlink" title="5. 交叉连接（CROSS JOIN）"></a>5. <strong>交叉连接（CROSS JOIN）</strong></h3><ul>
<li><strong>作用</strong>：返回笛卡尔积（所有可能的行组合）。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列 <span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>示例</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> users.name, products.price</span><br><span class="line"><span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> products;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="6-自连接（SELF-JOIN）"><a href="#6-自连接（SELF-JOIN）" class="headerlink" title="6. 自连接（SELF JOIN）"></a>6. <strong>自连接（SELF JOIN）</strong></h3><ul>
<li><strong>作用</strong>：同一表内连接，常用于层级数据（如员工与经理）。</li>
<li><strong>语法</strong>：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.列, b.列</span><br><span class="line"><span class="keyword">FROM</span> 表 a</span><br><span class="line"><span class="keyword">JOIN</span> 表 b <span class="keyword">ON</span> a.列 <span class="operator">=</span> b.列;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h1><p>以下是每种连接查询的具体实例，包含表结构、示例数据和对应的 SQL 语句：</p>
<hr>
<h3 id="1-内连接（INNER-JOIN）-1"><a href="#1-内连接（INNER-JOIN）-1" class="headerlink" title="1. 内连接（INNER JOIN）"></a><strong>1. 内连接（INNER JOIN）</strong></h3><h4 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> employees (</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    department_id <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE TABLE</span> departments (</span><br><span class="line">    department_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    department_name <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据"></a>示例数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> employees <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="number">101</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="number">102</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="keyword">NULL</span>);  <span class="comment">-- 无部门</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> departments <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">101</span>, <span class="string">&#x27;HR&#x27;</span>),</span><br><span class="line">(<span class="number">102</span>, <span class="string">&#x27;IT&#x27;</span>),</span><br><span class="line">(<span class="number">103</span>, <span class="string">&#x27;Finance&#x27;</span>);  <span class="comment">-- 无员工</span></span><br></pre></td></tr></table></figure>

<h4 id="查询示例"><a href="#查询示例" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取有部门的员工及其部门名称</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments </span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
</tr>
<tr>
<td>Bob</td>
<td>IT</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：仅返回 <code>employees</code> 和 <code>departments</code> 中 <code>department_id</code> 匹配的行，无部门的员工（Charlie）和无员工的部门（Finance）被过滤。</p>
<hr>
<h3 id="2-左连接（LEFT-JOIN）-1"><a href="#2-左连接（LEFT-JOIN）-1" class="headerlink" title="2. 左连接（LEFT JOIN）"></a><strong>2. 左连接（LEFT JOIN）</strong></h3><h4 id="查询示例-1"><a href="#查询示例-1" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取所有员工（包括无部门的员工）</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments </span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
</tr>
<tr>
<td>Bob</td>
<td>IT</td>
</tr>
<tr>
<td>Charlie</td>
<td>NULL</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：保留左表（<code>employees</code>）的所有行，无部门的员工 <code>department_name</code> 显示为 <code>NULL</code>。</p>
<hr>
<h3 id="3-右连接（RIGHT-JOIN）-1"><a href="#3-右连接（RIGHT-JOIN）-1" class="headerlink" title="3. 右连接（RIGHT JOIN）"></a><strong>3. 右连接（RIGHT JOIN）</strong></h3><h4 id="查询示例-2"><a href="#查询示例-2" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 获取所有部门（包括无员工的部门）</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments </span><br><span class="line"><span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
</tr>
<tr>
<td>Bob</td>
<td>IT</td>
</tr>
<tr>
<td>NULL</td>
<td>Finance</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：保留右表（<code>departments</code>）的所有行，无员工的部门对应的 <code>name</code> 显示为 <code>NULL</code>。</p>
<hr>
<h3 id="4-全外连接（FULL-OUTER-JOIN）-1"><a href="#4-全外连接（FULL-OUTER-JOIN）-1" class="headerlink" title="4. 全外连接（FULL OUTER JOIN）"></a><strong>4. 全外连接（FULL OUTER JOIN）</strong></h3><h4 id="查询示例-3"><a href="#查询示例-3" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用 UNION 模拟全外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.name, departments.department_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>name</th>
<th>department_name</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>HR</td>
</tr>
<tr>
<td>Bob</td>
<td>IT</td>
</tr>
<tr>
<td>Charlie</td>
<td>NULL</td>
</tr>
<tr>
<td>NULL</td>
<td>Finance</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：结合左连接和右连接的结果，返回所有员工和部门（包含未匹配的行）。</p>
<hr>
<h3 id="5-交叉连接（CROSS-JOIN）-1"><a href="#5-交叉连接（CROSS-JOIN）-1" class="headerlink" title="5. 交叉连接（CROSS JOIN）"></a><strong>5. 交叉连接（CROSS JOIN）</strong></h3><h4 id="表结构-1"><a href="#表结构-1" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> colors (color <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"><span class="keyword">CREATE TABLE</span> sizes (size <span class="type">VARCHAR</span>(<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> colors <span class="keyword">VALUES</span> (<span class="string">&#x27;Red&#x27;</span>), (<span class="string">&#x27;Blue&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT INTO</span> sizes <span class="keyword">VALUES</span> (<span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;M&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="查询示例-4"><a href="#查询示例-4" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 生成颜色和尺寸的所有组合</span></span><br><span class="line"><span class="keyword">SELECT</span> colors.color, sizes.size</span><br><span class="line"><span class="keyword">FROM</span> colors</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> sizes;</span><br></pre></td></tr></table></figure>

<h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>color</th>
<th>size</th>
</tr>
</thead>
<tbody><tr>
<td>Red</td>
<td>S</td>
</tr>
<tr>
<td>Red</td>
<td>M</td>
</tr>
<tr>
<td>Blue</td>
<td>S</td>
</tr>
<tr>
<td>Blue</td>
<td>M</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：返回两表的笛卡尔积（所有可能组合）。</p>
<hr>
<h3 id="6-自连接（SELF-JOIN）-1"><a href="#6-自连接（SELF-JOIN）-1" class="headerlink" title="6. 自连接（SELF JOIN）"></a><strong>6. 自连接（SELF JOIN）</strong></h3><h4 id="表结构-2"><a href="#表结构-2" class="headerlink" title="表结构"></a>表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> staff (</span><br><span class="line">    employee_id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    manager_id <span class="type">INT</span>  <span class="comment">-- 指向同一表的 employee_id</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT INTO</span> staff <span class="keyword">VALUES</span> </span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="keyword">NULL</span>),   <span class="comment">-- 顶级领导</span></span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="number">1</span>),        <span class="comment">-- Alice 的下属</span></span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="number">1</span>);    <span class="comment">-- Alice 的下属</span></span><br></pre></td></tr></table></figure>

<h4 id="查询示例-5"><a href="#查询示例-5" class="headerlink" title="查询示例"></a>查询示例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 显示员工及其上级经理</span></span><br><span class="line"><span class="keyword">SELECT</span> a.name <span class="keyword">AS</span> employee, b.name <span class="keyword">AS</span> manager</span><br><span class="line"><span class="keyword">FROM</span> staff a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> staff b </span><br><span class="line"><span class="keyword">ON</span> a.manager_id <span class="operator">=</span> b.employee_id;</span><br></pre></td></tr></table></figure>

<h4 id="结果-5"><a href="#结果-5" class="headerlink" title="结果"></a>结果</h4><table>
<thead>
<tr>
<th>employee</th>
<th>manager</th>
</tr>
</thead>
<tbody><tr>
<td>Alice</td>
<td>NULL</td>
</tr>
<tr>
<td>Bob</td>
<td>Alice</td>
</tr>
<tr>
<td>Charlie</td>
<td>Alice</td>
</tr>
</tbody></table>
<p><strong>说明</strong>：通过自连接将员工与其上级关联，左表为员工，右表为对应的上级。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过具体示例可以直观理解不同连接的行为：</p>
<ul>
<li><strong>INNER JOIN</strong>：仅保留匹配的行。</li>
<li><strong>LEFT&#x2F;RIGHT JOIN</strong>：保留主表所有行，从表无匹配时填充 <code>NULL</code>。</li>
<li><strong>FULL OUTER JOIN</strong>：结合左右连接的并集。</li>
<li><strong>CROSS JOIN</strong>：生成笛卡尔积。</li>
<li><strong>SELF JOIN</strong>：同一表内关联不同行。</li>
</ul>
<p>力扣已刷相关题：</p>
<p>表: <code>Person</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">personId 是该表的主键（具有唯一值的列）。</span><br><span class="line">该表包含一些人的 ID 和他们的姓和名的信息。</span><br></pre></td></tr></table></figure>

<p>表: <code>Address</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">addressId 是该表的主键（具有唯一值的列）。</span><br><span class="line">该表的每一行都包含一个 ID = PersonId 的人的城市和州的信息。</span><br></pre></td></tr></table></figure>

<p>编写解决方案，报告 <code>Person</code> 表中每个人的姓、名、城市和州。如果 <code>personId</code> 的地址不在 <code>Address</code> 表中，则报告为 <code>null</code> 。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 
Person表:
+----------+----------+-----------+
| personId | lastName | firstName |
+----------+----------+-----------+
| 1        | Wang     | Allen     |
| 2        | Alice    | Bob       |
+----------+----------+-----------+
Address表:
+-----------+----------+---------------+------------+
| addressId | personId | city          | state      |
+-----------+----------+---------------+------------+
| 1         | 2        | New York City | New York   |
| 2         | 3        | Leetcode      | California |
+-----------+----------+---------------+------------+
<strong>输出:</strong> 
+-----------+----------+---------------+----------+
| firstName | lastName | city          | state    |
+-----------+----------+---------------+----------+
| Allen     | Wang     | Null          | Null     |
| Bob       | Alice    | New York City | New York |
+-----------+----------+---------------+----------+
<strong>解释:</strong> 
地址表中没有 personId = 1 的地址，所以它们的城市和州返回 null。
addressId = 1 包含了 personId = 2 的地址信息。</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 题解</span><br><span class="line"><span class="keyword">select</span> firstName, lastName, city, state </span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address </span><br><span class="line"><span class="keyword">on</span> Person.PersonID <span class="operator">=</span> Address.PersonID</span><br></pre></td></tr></table></figure>

<p>表：<code>Employee</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| empId       | int     |</span><br><span class="line">| name        | varchar |</span><br><span class="line">| supervisor  | int     |</span><br><span class="line">| salary      | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">empId 是该表中具有唯一值的列。</span><br><span class="line">该表的每一行都表示员工的姓名和 id，以及他们的工资和经理的 id。</span><br></pre></td></tr></table></figure>

<p>表：<code>Bonus</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+------+</span><br><span class="line">| Column Name | Type |</span><br><span class="line">+-------------+------+</span><br><span class="line">| empId       | int  |</span><br><span class="line">| bonus       | int  |</span><br><span class="line">+-------------+------+</span><br><span class="line">empId 是该表具有唯一值的列。</span><br><span class="line">empId 是 Employee 表中 empId 的外键(reference 列)。</span><br><span class="line">该表的每一行都包含一个员工的 id 和他们各自的奖金。</span><br></pre></td></tr></table></figure>

<p>编写解决方案，报告每个奖金 <strong>少于</strong> <code>1000</code> 的员工的姓名和奖金数额。</p>
<p>以 <strong>任意顺序</strong> 返回结果表。</p>
<p>结果格式如下所示。</p>
<p><strong>示例 1：</strong></p>
<pre><b>输入：</b>
Employee table:
+-------+--------+------------+--------+
| empId | name   | supervisor | salary |
+-------+--------+------------+--------+
| 3     | Brad   | null       | 4000   |
| 1     | John   | 3          | 1000   |
| 2     | Dan    | 3          | 2000   |
| 4     | Thomas | 3          | 4000   |
+-------+--------+------------+--------+
Bonus table:
+-------+-------+
| empId | bonus |
+-------+-------+
| 2     | 500   |
| 4     | 2000  |
+-------+-------+
<b>输出：</b>
+------+-------+
| name | bonus |
+------+-------+
| Brad | null  |
| John | null  |
| Dan  | 500   |
+------+-------+</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 题解</span><br><span class="line"><span class="keyword">select</span> name, bonus </span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">left</span> <span class="keyword">join</span> Bonus </span><br><span class="line"><span class="keyword">on</span> Employee.empId <span class="operator">=</span> Bonus.empId </span><br><span class="line"><span class="keyword">where</span> bonus <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">or</span> bonus <span class="operator">&lt;</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql常用操作</title>
    <url>/2025/02/27/mysql/</url>
    <content><![CDATA[<h3 id="一、数据库操作"><a href="#一、数据库操作" class="headerlink" title="一、数据库操作"></a><strong>一、数据库操作</strong></h3><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE IF NOT EXISTS `test_db` DEFAULT CHARACTER SET utf8mb4;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：创建名为 <code>test_db</code> 的数据库，字符集为 <code>utf8mb4</code>（支持中文和表情符号）。</p>
<h4 id="2-切换数据库"><a href="#2-切换数据库" class="headerlink" title="2. 切换数据库"></a>2. 切换数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE `test_db`;</span><br></pre></td></tr></table></figure>

<h4 id="3-删除数据库"><a href="#3-删除数据库" class="headerlink" title="3. 删除数据库"></a>3. 删除数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS `test_db`;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="二、表操作"><a href="#二、表操作" class="headerlink" title="二、表操作"></a><strong>二、表操作</strong></h3><h4 id="1-创建表（含字段约束）"><a href="#1-创建表（含字段约束）" class="headerlink" title="1. 创建表（含字段约束）"></a>1. 创建表（含字段约束）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `id` INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  `name` VARCHAR(50) NOT NULL,</span><br><span class="line">  `email` VARCHAR(100) UNIQUE,</span><br><span class="line">  `age` INT DEFAULT 18,</span><br><span class="line">  `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>字段说明</strong>：</p>
<ul>
<li><code>PRIMARY KEY</code>：主键约束</li>
<li><code>AUTO_INCREMENT</code>：自增</li>
<li><code>UNIQUE</code>：唯一约束</li>
<li><code>DEFAULT</code>：默认值</li>
</ul>
<h4 id="2-修改表结构"><a href="#2-修改表结构" class="headerlink" title="2. 修改表结构"></a>2. 修改表结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 添加新列</span><br><span class="line">ALTER TABLE `users` ADD COLUMN `gender` ENUM(&#x27;male&#x27;, &#x27;female&#x27;) AFTER `age`;</span><br><span class="line"></span><br><span class="line">-- 修改列类型</span><br><span class="line">ALTER TABLE `users` MODIFY COLUMN `name` VARCHAR(100);</span><br><span class="line"></span><br><span class="line">-- 删除列</span><br><span class="line">ALTER TABLE `users` DROP COLUMN `gender`;</span><br></pre></td></tr></table></figure>

<h4 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3. 删除表"></a>3. 删除表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `users`;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="三、数据操作（CRUD）"><a href="#三、数据操作（CRUD）" class="headerlink" title="三、数据操作（CRUD）"></a><strong>三、数据操作（CRUD）</strong></h3><h4 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 插入单条数据</span><br><span class="line">INSERT INTO `users` (`name`, `email`, `age`) </span><br><span class="line">VALUES (&#x27;Alice&#x27;, &#x27;alice@example.com&#x27;, 25);</span><br><span class="line"></span><br><span class="line">-- 插入多条数据</span><br><span class="line">INSERT INTO `users` (`name`, `email`) </span><br><span class="line">VALUES (&#x27;Bob&#x27;, &#x27;bob@test.com&#x27;), (&#x27;Charlie&#x27;, &#x27;charlie@test.com&#x27;);</span><br></pre></td></tr></table></figure>

<h4 id="2-查询数据"><a href="#2-查询数据" class="headerlink" title="2. 查询数据"></a>2. 查询数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询所有字段</span><br><span class="line">SELECT * FROM `users`;</span><br><span class="line"></span><br><span class="line">-- 条件查询（WHERE）</span><br><span class="line">SELECT `name`, `age` FROM `users` WHERE `age` &gt; 20;</span><br><span class="line"></span><br><span class="line">-- 排序（ORDER BY）</span><br><span class="line">SELECT * FROM `users` ORDER BY `created_at` DESC;</span><br><span class="line"></span><br><span class="line">-- 分页（LIMIT）</span><br><span class="line">SELECT * FROM `users` LIMIT 10 OFFSET 0; -- 第1页，每页10条</span><br></pre></td></tr></table></figure>

<h4 id="3-更新数据"><a href="#3-更新数据" class="headerlink" title="3. 更新数据"></a>3. 更新数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE `users` </span><br><span class="line">SET `age` = 30, `email` = &#x27;alice_new@example.com&#x27; </span><br><span class="line">WHERE `id` = 1;</span><br></pre></td></tr></table></figure>

<h4 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4. 删除数据"></a>4. 删除数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM `users` WHERE `id` = 3;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、复杂查询"><a href="#四、复杂查询" class="headerlink" title="四、复杂查询"></a><strong>四、复杂查询</strong></h3><h4 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 统计总数、平均值</span><br><span class="line">SELECT COUNT(*) AS total_users, AVG(age) AS avg_age FROM `users`;</span><br><span class="line"></span><br><span class="line">-- 分组统计（GROUP BY）</span><br><span class="line">SELECT `gender`, COUNT(*) AS count FROM `users` GROUP BY `gender`;</span><br></pre></td></tr></table></figure>

<h4 id="2-连接查询（JOIN）"><a href="#2-连接查询（JOIN）" class="headerlink" title="2. 连接查询（JOIN）"></a>2. 连接查询（JOIN）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建订单表</span><br><span class="line">CREATE TABLE `orders` (</span><br><span class="line">  `order_id` INT PRIMARY KEY,</span><br><span class="line">  `user_id` INT,</span><br><span class="line">  `amount` DECIMAL(10,2),</span><br><span class="line">  FOREIGN KEY (`user_id`) REFERENCES `users`(`id`)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 内连接（INNER JOIN）</span><br><span class="line">SELECT u.`name`, o.`order_id`, o.`amount`</span><br><span class="line">FROM `users` u</span><br><span class="line">INNER JOIN `orders` o ON u.`id` = o.`user_id`;</span><br></pre></td></tr></table></figure>

<h4 id="3-子查询"><a href="#3-子查询" class="headerlink" title="3. 子查询"></a>3. 子查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT `name` </span><br><span class="line">FROM `users` </span><br><span class="line">WHERE `id` IN (SELECT `user_id` FROM `orders` WHERE `amount` &gt; 100);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="五、高级功能"><a href="#五、高级功能" class="headerlink" title="五、高级功能"></a><strong>五、高级功能</strong></h3><h4 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1. 索引优化"></a>1. 索引优化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建索引</span><br><span class="line">CREATE INDEX `idx_email` ON `users` (`email`);</span><br><span class="line"></span><br><span class="line">-- 查看索引</span><br><span class="line">SHOW INDEX FROM `users`;</span><br></pre></td></tr></table></figure>

<h4 id="2-事务处理"><a href="#2-事务处理" class="headerlink" title="2. 事务处理"></a>2. 事务处理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">UPDATE `account` SET balance = balance - 100 WHERE user_id = 1;</span><br><span class="line">UPDATE `account` SET balance = balance + 100 WHERE user_id = 2;</span><br><span class="line">COMMIT; -- 提交事务</span><br><span class="line">-- ROLLBACK; -- 回滚事务</span><br></pre></td></tr></table></figure>

<h4 id="3-用户权限管理"><a href="#3-用户权限管理" class="headerlink" title="3. 用户权限管理"></a>3. 用户权限管理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建用户并授权</span><br><span class="line">CREATE USER &#x27;dev_user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password123&#x27;;</span><br><span class="line">GRANT SELECT, INSERT, UPDATE ON `test_db`.* TO &#x27;dev_user&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="六、实用命令"><a href="#六、实用命令" class="headerlink" title="六、实用命令"></a><strong>六、实用命令</strong></h3><h4 id="1-导入-导出数据"><a href="#1-导入-导出数据" class="headerlink" title="1. 导入&#x2F;导出数据"></a>1. 导入&#x2F;导出数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 导出整个数据库（命令行）</span><br><span class="line">mysqldump -u root -p test_db &gt; backup.sql</span><br><span class="line"></span><br><span class="line"># 导入数据</span><br><span class="line">mysql -u root -p test_db &lt; backup.sql</span><br></pre></td></tr></table></figure>

<h4 id="2-查看表结构"><a href="#2-查看表结构" class="headerlink" title="2. 查看表结构"></a>2. 查看表结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC `users`;</span><br></pre></td></tr></table></figure>

<h4 id="3-查看建表语句"><a href="#3-查看建表语句" class="headerlink" title="3. 查看建表语句"></a>3. 查看建表语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE TABLE `users`;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="高频场景示例"><a href="#高频场景示例" class="headerlink" title="高频场景示例"></a><strong>高频场景示例</strong></h3><h4 id="场景1：分页查询用户列表（每页5条）"><a href="#场景1：分页查询用户列表（每页5条）" class="headerlink" title="场景1：分页查询用户列表（每页5条）"></a>场景1：分页查询用户列表（每页5条）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `users` </span><br><span class="line">ORDER BY `id` </span><br><span class="line">LIMIT 5 OFFSET 0; -- 第1页</span><br></pre></td></tr></table></figure>

<h4 id="场景2：模糊查询（查找名字包含-“DB”-的用户）"><a href="#场景2：模糊查询（查找名字包含-“DB”-的用户）" class="headerlink" title="场景2：模糊查询（查找名字包含 “DB” 的用户）"></a>场景2：模糊查询（查找名字包含 “DB” 的用户）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM `users` </span><br><span class="line">WHERE `name` LIKE &#x27;%DB%&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="场景3：批量更新状态"><a href="#场景3：批量更新状态" class="headerlink" title="场景3：批量更新状态"></a>场景3：批量更新状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE `products` </span><br><span class="line">SET `status` = &#x27;offline&#x27; </span><br><span class="line">WHERE `stock` = 0;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题——IF函数</title>
    <url>/2025/03/04/mysqlnote-1/</url>
    <content><![CDATA[<h1 id="610-判断三角形"><a href="#610-判断三角形" class="headerlink" title="610.判断三角形"></a>610.判断三角形</h1><p>表: <code>Triangle</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+------+</span><br><span class="line">| Column Name | Type |</span><br><span class="line">+-------------+------+</span><br><span class="line">| x           | int  |</span><br><span class="line">| y           | int  |</span><br><span class="line">| z           | int  |</span><br><span class="line">+-------------+------+</span><br><span class="line">在 SQL 中，(x, y, z)是该表的主键列。</span><br><span class="line">该表的每一行包含三个线段的长度。</span><br></pre></td></tr></table></figure>

<p>对每三个线段报告它们是否可以形成一个三角形。</p>
<p>以 **任意顺序 **返回结果表。</p>
<p>查询结果格式如下所示。</p>
<p><strong>示例 1:</strong></p>
<pre><strong>输入:</strong> 
Triangle 表:
+----+----+----+
| x  | y  | z  |
+----+----+----+
| 13 | 15 | 30 |
| 10 | 20 | 15 |
+----+----+----+
<strong>输出:</strong> 
+----+----+----+----------+
| x  | y  | z  | triangle |
+----+----+----+----------+
| 13 | 15 | 30 | No       |
| 10 | 20 | 15 | Yes      |
+----+----+----+----------+</pre>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> x,y,z,<span class="keyword">if</span>(x+y&gt;z and x+z&gt;y and y+z&gt;x, <span class="string">&quot;Yes&quot;</span>, <span class="string">&quot;No&quot;</span>) as triangle</span><br><span class="line">from triangle</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3学习记录</title>
    <url>/2025/03/11/webNote/</url>
    <content><![CDATA[<hr>
<h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><p>关键属性：<code>float</code></p>
<p>值：left、right</p>
<p>清除浮动：本质是闭合浮动</p>
<ul>
<li>方法1：overflow: hidden</li>
<li>方法2：伪元素</li>
<li>方法3</li>
<li>方法4</li>
</ul>
<h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><p>关键属性：<code>position</code></p>
<p>值：static、relative、absolute、fixed、sticky</p>
<blockquote>
<p>子绝父相</p>
</blockquote>
<p>相对定位可以使用 <code>margin:auto</code>设置居中，绝对定位无法使用，需要计算设置</p>
<h2 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h2><p>z-index:提高层级</p>
<p>display：none</p>
<p>visibility：visible &#x2F; hidden</p>
<p>overflow：</p>
<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h1 id="CSS3结构伪类选择器"><a href="#CSS3结构伪类选择器" class="headerlink" title="CSS3结构伪类选择器"></a>CSS3结构伪类选择器</h1><p>E::first-child</p>
<p>E::last-child</p>
<p>E:nth-child：nth-child(even)、nth-child(odd)、nth-child(表达式)[n,2n,2n-1,n+1,-n+1] 指定元素E的第几个，先匹配类型后匹配几个</p>
<p>E:nth-of-type(): 指定元素E的第几个，先匹配指定元素后匹配类型</p>
<h1 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h1><p>并不是真正元素，在文档中找不到。</p>
<p>E::before()</p>
<p>E::after()</p>
<p>都必须存在content属性</p>
<h1 id="CSS3盒模型"><a href="#CSS3盒模型" class="headerlink" title="CSS3盒模型"></a>CSS3盒模型</h1><p>box-size：border-size、content-size</p>
<h1 id="css3其他特性"><a href="#css3其他特性" class="headerlink" title="css3其他特性"></a>css3其他特性</h1><p>calc(): calc(100%-15px)</p>
<p>filter: blur(15px)</p>
<p>transition: 变化属性  花费时间 运动曲线 开始时间</p>
<p>transition: all</p>
<p><strong>动画：</strong></p>
<p>定义动画</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyframes 动画名</span><br><span class="line">&#123;</span><br><span class="line"> 	0%&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	100%&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配合使用属性</p>
<p><code>animation-name</code></p>
<p><code>animation-duration</code></p>
<p>translate()：移动元素，并不会改变其他盒子</p>
<p>animation属性</p>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣Mysql每日一题(interval)</title>
    <url>/2025/03/03/mysqlnote/</url>
    <content><![CDATA[<p>在 MySQL 中，<code>INTERVAL</code> 不是一种字段类型，而是一个<strong>用于日期和时间计算的运算符</strong>。它通常与日期函数（如 <code>DATE_ADD()</code>, <code>DATE_SUB()</code>）或直接日期表达式结合使用，用来表示时间间隔。以下是 <code>INTERVAL</code> 的常见用法和示例：</p>
<h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a><strong>1. 基本语法</strong></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATE_ADD(base_date, <span class="type">INTERVAL</span> <span class="keyword">value</span> unit)</span><br><span class="line">DATE_SUB(base_date, <span class="type">INTERVAL</span> <span class="keyword">value</span> unit)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>base_date</code></strong>：基准日期（如 <code>CURDATE()</code>, <code>NOW()</code> 或字段名）。</li>
<li><strong><code>value</code></strong>：数值（正负均可）。</li>
<li><strong><code>unit</code></strong>：时间单位（如 <code>DAY</code>, <code>MONTH</code>, <code>YEAR</code>, <code>HOUR</code>, <code>MINUTE</code> 等）。</li>
</ul>
<hr>
<h3 id="2-常见使用场景"><a href="#2-常见使用场景" class="headerlink" title="2. 常见使用场景"></a><strong>2. 常见使用场景</strong></h3><h4 id="场景-1：日期加减"><a href="#场景-1：日期加减" class="headerlink" title="场景 1：日期加减"></a><strong>场景 1：日期加减</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 当前时间加 7 天</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(NOW(), <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>) <span class="keyword">AS</span> future_date;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当前时间减 3 小时</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">HOUR</span>) <span class="keyword">AS</span> past_time;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直接使用 `+ INTERVAL` 简化语法</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span> <span class="keyword">AS</span> next_month;</span><br></pre></td></tr></table></figure>

<h4 id="场景-2：计算字段的过期时间"><a href="#场景-2：计算字段的过期时间" class="headerlink" title="场景 2：计算字段的过期时间"></a><strong>场景 2：计算字段的过期时间</strong></h4><p>假设有一个 <code>orders</code> 表，需要计算订单到期时间（创建时间 + 30 天）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    order_id, </span><br><span class="line">    created_at, </span><br><span class="line">    created_at <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">30</span> <span class="keyword">DAY</span> <span class="keyword">AS</span> expire_date</span><br><span class="line"><span class="keyword">FROM</span> orders;</span><br></pre></td></tr></table></figure>

<h4 id="场景-3：过滤时间范围"><a href="#场景-3：过滤时间范围" class="headerlink" title="场景 3：过滤时间范围"></a><strong>场景 3：过滤时间范围</strong></h4><p>查询最近 7 天内的订单：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="operator">&gt;=</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure>

<h4 id="场景-4：生成时间序列"><a href="#场景-4：生成时间序列" class="headerlink" title="场景 4：生成时间序列"></a><strong>场景 4：生成时间序列</strong></h4><p>生成过去 12 个月的月份序列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    DATE_FORMAT(NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> n <span class="keyword">MONTH</span>, <span class="string">&#x27;%Y-%m&#x27;</span>) <span class="keyword">AS</span> <span class="keyword">month</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">0</span> <span class="keyword">AS</span> n <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">2</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">3</span> <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">4</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">5</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">6</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">7</span> <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">8</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">9</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">10</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">11</span></span><br><span class="line">) <span class="keyword">AS</span> numbers;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-支持的-INTERVAL-单位"><a href="#3-支持的-INTERVAL-单位" class="headerlink" title="3. 支持的 INTERVAL 单位"></a><strong>3. 支持的 <code>INTERVAL</code> 单位</strong></h3><p>MySQL 支持以下时间单位：</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>MICROSECOND</code></td>
<td>微秒</td>
</tr>
<tr>
<td><code>SECOND</code></td>
<td>秒</td>
</tr>
<tr>
<td><code>MINUTE</code></td>
<td>分钟</td>
</tr>
<tr>
<td><code>HOUR</code></td>
<td>小时</td>
</tr>
<tr>
<td><code>DAY</code></td>
<td>天</td>
</tr>
<tr>
<td><code>WEEK</code></td>
<td>周</td>
</tr>
<tr>
<td><code>MONTH</code></td>
<td>月</td>
</tr>
<tr>
<td><code>QUARTER</code></td>
<td>季度（3 个月）</td>
</tr>
<tr>
<td><code>YEAR</code></td>
<td>年</td>
</tr>
<tr>
<td><code>SECOND_MICROSECOND</code></td>
<td>秒和微秒（如 <code>&#39;30.5&#39; SECOND_MICROSECOND</code>）</td>
</tr>
<tr>
<td><code>MINUTE_MICROSECOND</code></td>
<td>分钟、秒和微秒</td>
</tr>
<tr>
<td>…（其他复合单位）</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-存储时间间隔的字段设计"><a href="#4-存储时间间隔的字段设计" class="headerlink" title="4. 存储时间间隔的字段设计"></a><strong>4. 存储时间间隔的字段设计</strong></h3><p>如果需要在表中存储时间间隔（如“有效期 30 天”），通常用以下两种方式：</p>
<h4 id="方式-1：分开存储数值和单位"><a href="#方式-1：分开存储数值和单位" class="headerlink" title="方式 1：分开存储数值和单位"></a><strong>方式 1：分开存储数值和单位</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> subscriptions (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    duration <span class="type">INT</span>,       <span class="comment">-- 时间长度（如 30）</span></span><br><span class="line">    duration_unit <span class="type">VARCHAR</span>(<span class="number">10</span>)  <span class="comment">-- 单位（如 &#x27;DAY&#x27;）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算过期时间</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    DATE_ADD(start_date, <span class="type">INTERVAL</span> duration duration_unit) <span class="keyword">AS</span> expire_date</span><br><span class="line"><span class="keyword">FROM</span> subscriptions;</span><br></pre></td></tr></table></figure>

<h4 id="方式-2：统一存储为秒数"><a href="#方式-2：统一存储为秒数" class="headerlink" title="方式 2：统一存储为秒数"></a><strong>方式 2：统一存储为秒数</strong></h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> tasks (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    timeout_seconds <span class="type">INT</span>  <span class="comment">-- 存储总秒数（如 3600 表示 1 小时）</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转换为时间间隔</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    DATE_ADD(start_time, <span class="type">INTERVAL</span> timeout_seconds <span class="keyword">SECOND</span>) <span class="keyword">AS</span> end_time</span><br><span class="line"><span class="keyword">FROM</span> tasks;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-复杂示例：自动分区按时间间隔"><a href="#5-复杂示例：自动分区按时间间隔" class="headerlink" title="5. 复杂示例：自动分区按时间间隔"></a><strong>5. 复杂示例：自动分区按时间间隔</strong></h3><p>使用 <code>INTERVAL</code> 创建按月的自动分区表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> logs (</span><br><span class="line">    log_date DATETIME,</span><br><span class="line">    content TEXT</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> COLUMNS(log_date) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p202301 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;2023-02-01&#x27;</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p202302 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;2023-03-01&#x27;</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p202303 <span class="keyword">VALUES</span> LESS THAN (<span class="string">&#x27;2023-04-01&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a><strong>6. 注意事项</strong></h3><ol>
<li><p><strong>时区问题</strong><br>使用 <code>INTERVAL</code> 计算时，确保基准日期和结果的时区一致（可通过 <code>CONVERT_TZ()</code> 转换）。</p>
</li>
<li><p><strong>闰年和月末</strong><br>加减月份时，MySQL 会自动处理月末：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 2023-01-31 + 1 MONTH → 2023-02-28</span></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2023-01-31&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span>); </span><br></pre></td></tr></table></figure></li>
<li><p><strong>索引失效</strong><br>避免在 <code>WHERE</code> 条件中对字段使用函数（如 <code>DATE_ADD(column, INTERVAL ...)</code>），可能导致索引失效。建议改写为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 优化前（索引可能失效）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> logs <span class="keyword">WHERE</span> DATE_ADD(log_date, <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>) <span class="operator">&gt;</span> NOW();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优化后（直接比较字段）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> logs <span class="keyword">WHERE</span> log_date <span class="operator">&gt;</span> NOW() <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="number">7</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><code>INTERVAL</code> 是 MySQL 中处理日期和时间计算的核心工具，适用于：</p>
<ul>
<li>动态计算未来或过去的日期。</li>
<li>生成时间序列或过滤时间范围。</li>
<li>设计需要存储时间间隔的业务逻辑。</li>
</ul>
<p>结合 <code>DATE_ADD()</code>、<code>DATE_SUB()</code> 和直接日期表达式，可以高效实现复杂的时间操作。</p>
<h1 id="题目：197-上升的温度"><a href="#题目：197-上升的温度" class="headerlink" title="题目：197.上升的温度"></a>题目：197.上升的温度</h1><p>表： <code>Weather</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| id            | int     |</span><br><span class="line">| recordDate    | date    |</span><br><span class="line">| temperature   | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">id 是该表具有唯一值的列。</span><br><span class="line">没有具有相同 recordDate 的不同行。</span><br><span class="line">该表包含特定日期的温度信息</span><br></pre></td></tr></table></figure>

<p>编写解决方案，找出与之前（昨天的）日期相比温度更高的所有日期的 <code>id</code> 。</p>
<p>返回结果 <strong>无顺序要求</strong> 。</p>
<p>结果格式如下例子所示。</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>
Weather 表：
+----+------------+-------------+
| id | recordDate | Temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+
<strong>输出：</strong>
+----+
| id |
+----+
| 2  |
| 4  |
+----+
<strong>解释：</strong>
2015-01-02 的温度比前一天高（10 -> 25）
2015-01-04 的温度比前一天高（20 -> 30）</pre>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> w1.id</span><br><span class="line"><span class="keyword">from</span> Weather w1, Weather w2</span><br><span class="line"><span class="keyword">where</span> w1.recordDate <span class="operator">-</span> <span class="type">interval</span> <span class="number">1</span> <span class="keyword">day</span> <span class="operator">=</span> w2.recordDate</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">w1.temperature <span class="operator">&gt;</span> w2.temperature</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++语法学习笔记（持续更新）</title>
    <url>/2025/02/07/noteC/</url>
    <content><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C++风格字符串库 <code>#include&lt;cstring&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(_string)</span><br></pre></td></tr></table></figure>

<p>返回：_string长度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(_s1, _s2)</span><br></pre></td></tr></table></figure>

<p>功能：将_s2的值复制到_s1，返回值为_s1的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(str1, str2)</span><br></pre></td></tr></table></figure>

<p>功能：比较str1与str2的值。</p>
<p><strong>逐字符比较</strong> ：</p>
<ul>
<li>从字符串的第一个字符开始，逐个比较 <code>str1</code> 和 <code>str2</code> 中对应位置的字符。</li>
<li>比较的依据是字符的 ASCII 值。</li>
</ul>
<p><strong>返回值规则</strong> ：</p>
<ul>
<li>如果 <code>str1</code> 和 <code>str2</code> 完全相同，返回 <code>0</code>。</li>
<li>如果 <code>str1</code> 的第一个不同字符的 ASCII 值小于 <code>str2</code> 的对应字符，返回一个 <strong>负整数</strong> 。</li>
<li>如果 <code>str1</code> 的第一个不同字符的 ASCII 值大于 <code>str2</code> 的对应字符，返回一个 <strong>正整数</strong> 。</li>
</ul>
<p><strong>结束条件</strong> ：</p>
<ul>
<li>如果其中一个字符串提前结束（遇到 <code>\0</code>），而另一个字符串还有字符，则较短的字符串被认为是“较小”的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strchr</span>(str,ch)</span><br></pre></td></tr></table></figure>

<p>功能：返回str中第一个出现ch字符的地址。未找到则返回 <code>null</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strstr</span>(str1, str2)</span><br></pre></td></tr></table></figure>

<p>功能：返回str1中第一次出现str2的位置。未找到则返回 <code>null</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcat</span>(str1, str2)</span><br></pre></td></tr></table></figure>

<p>功能：连接两个字符串。</p>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>C&#x2F;C++常见修饰符</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th>修饰符功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">const</td>
<td>const 定义常量，表示该变量的值不能被修改。</td>
</tr>
<tr>
<td align="left">volatile</td>
<td>修饰符<strong>volatile</strong> 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。</td>
</tr>
<tr>
<td align="left">restrict</td>
<td>由<strong>restrict</strong> 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。</td>
</tr>
<tr>
<td align="left">mutable</td>
<td>mutable 用于修饰类的成员变量。被 mutable 修饰的成员变量可以被修改，即使它们所在的对象是 const 的。</td>
</tr>
<tr>
<td align="left">static</td>
<td>用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。</td>
</tr>
<tr>
<td align="left">register</td>
<td>用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。</td>
</tr>
</tbody></table>
<h2 id="const举例"><a href="#const举例" class="headerlink" title="const举例"></a>const举例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> num1 = <span class="number">11</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>*a = &amp;num</span><br><span class="line">*a = <span class="number">11</span>; <span class="comment">// 报错</span></span><br><span class="line">cout&lt;&lt;*a;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> b = &amp;num</span><br><span class="line">b = num1;<span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<h3 id="const高级用法"><a href="#const高级用法" class="headerlink" title="const高级用法"></a>const高级用法</h3><blockquote>
<p>暂未补充</p>
</blockquote>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>本质即为存放元素的地址，存在地址的地址即二级地址，以此类推。</p>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>：：数组存放元素为指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> var[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptrs[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">	ptrs[i] = &amp;var[i];</span><br><span class="line">	std::cout&lt;&lt;*ptrs[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存放字符串的数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* strs[<span class="number">3</span>] = &#123;</span><br><span class="line">	<span class="string">&quot;AI&quot;</span>,</span><br><span class="line">	<span class="string">&quot;MechineLearn&quot;</span>,</span><br><span class="line">	<span class="string">&quot;DeepLearn&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数返回指针</p>
<blockquote>
<p>函数返回值不能返回局部变量的地址，除非该变量声明为static</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">getValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//int temp = 1; 则会报错无法返回局部变量值</span></span><br><span class="line">	<span class="keyword">return</span> &amp;temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *var = <span class="literal">nullptr</span>;</span><br><span class="line">	var = <span class="built_in">getValue</span>();<span class="comment">// var被赋值为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li>引用变量是一个别名。</li>
<li>一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</li>
<li>引用必须在定义时初始化，并且一旦绑定到一个变量后，就不能再绑定到其他变量。</li>
</ul>
<p>普通引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">17</span>;</span><br><span class="line"><span class="type">int</span> &amp;cp = num;</span><br></pre></td></tr></table></figure>

<p>数组引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a1[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;a2)[] = a;</span><br></pre></td></tr></table></figure>

<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>优点：</p>
<ul>
<li><strong>简单数据封装</strong> ：适合封装多种类型的简单数据，通常用于数据的存储。</li>
<li><strong>轻量级</strong> ：相比 <code>class</code>，结构体语法更简洁，适合小型数据对象。</li>
<li><strong>面向对象支持</strong> ：支持构造函数、成员函数和访问权限控制，可以实现面向对象的设计。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">type_name</span> &#123;</span><br><span class="line">type1 member_name1;</span><br><span class="line">type2 member_name2;</span><br><span class="line">type3 member_name3;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">type_name</span> s1&#123;val1,val2,val3&#125;;</span><br><span class="line">	std::cout &lt;&lt; s<span class="number">1.</span>member_name1 &lt;&lt; std::endl; <span class="comment">//结构体成员使用 .</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">type_name</span> *struct_pointer; <span class="comment">//指向结构的指针</span></span><br><span class="line">	struct_pointer = &amp;s1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typedef关键字"><a href="#typedef关键字" class="headerlink" title="typedef关键字"></a>typedef关键字</h2><p>将类型名取别名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">type_name</span> newType;<span class="comment">// typedef重命名</span></span><br><span class="line"></span><br><span class="line">newType t2;</span><br></pre></td></tr></table></figure>

<h2 id="结构体与类的区别"><a href="#结构体与类的区别" class="headerlink" title="结构体与类的区别"></a>结构体与类的区别</h2><p>在 C++ 中，struct 和 class 本质上非常相似，唯一的区别在于默认的访问权限：</p>
<ul>
<li>struct 默认的成员和继承是 public。</li>
<li>class 默认的成员和继承是 private。</li>
</ul>
<p>可以将 <code>struct</code> 当作一种简化形式的 <code>class</code>，适合用于没有太多复杂功能的简单数据封装。</p>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><p>类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。类可以被看作是一种模板，可以用来创建具有相同属性和行为的多个对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 访问修饰符：public</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">      <span class="comment">// 成员函数声明</span></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">( <span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 成员函数定义1</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Box::getV</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 成员函数定义2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Box::set</span><span class="params">( <span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    breadth = bre;</span><br><span class="line">    height = hei;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-类访问修饰符"><a href="#C-类访问修饰符" class="headerlink" title="C++ 类访问修饰符"></a>C++ <strong>类访问修饰符</strong></h2><p>关键字 <strong>public、private、protected</strong> 称为访问修饰符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 公有成员</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 受保护成员</span></span><br><span class="line">  <span class="comment">//与私有成员十分相似，但有一点不同，protected（受保护）成员在子类中是可访问的。</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 私有成员</span></span><br><span class="line">  <span class="comment">//私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。</span></span><br><span class="line">  <span class="comment">//实际操作中，在私有区域定义数据，在公有区域定义相关的函数，在类的外部也可以调用这些函数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继承后的特点</p>
<p>有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。</p>
<ul>
<li><strong>public 继承：</strong> 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private</li>
<li><strong>protected 继承：</strong> 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private</li>
<li><strong>private 继承：</strong> 基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private</li>
</ul>
<p>但无论哪种继承方式，下面两点都没有改变：</p>
<ul>
<li>private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；</li>
<li>protected 成员可以被派生类访问。</li>
</ul>
<blockquote>
<p>如果继承时不显示声明是  <strong>private，protected，public 继承，则默认是 private 继承，在 struct 中默认 public 继承</strong></p>
</blockquote>
<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>静态成员函数与普通成员函数的区别：</p>
<ul>
<li>静态成员函数没有 <code>this</code> 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。</li>
<li>普通成员函数有 <code>this</code>指针，可以访问类中的任意成员；而静态成员函数没有 <code>this</code>指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 静态成员变量</span></span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> objCount;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">        <span class="built_in">Father</span>();</span><br><span class="line">	<span class="comment">// 析构函数 </span></span><br><span class="line">        ~<span class="built_in">Father</span>(); </span><br><span class="line">	<span class="comment">// 友元函数 </span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GN</span><span class="params">(Father *f)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意：初始化类的静态成员</span></span><br><span class="line"><span class="type">int</span> Father::objCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>静态成员变量可以使用 <code>类名::静态变量</code>访问，静态成员函数无法使用 <code>this</code>。</p>
<h2 id="C-类成员函数"><a href="#C-类成员函数" class="headerlink" title="C++ 类成员函数"></a>C++ <strong>类成员函数</strong></h2><p>成员函数可以定义在类定义内部，或者单独使用<strong>范围解析运算符 ::</strong> 来定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="type">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="type">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">double</span> height;      <span class="comment">// 高度</span></span><br><span class="line">      <span class="comment">// 定义在类定义内部</span></span><br><span class="line">      <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义在类定义外部</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>使用初始化列表来初始化字段。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>*name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Father</span>(<span class="type">char</span>*n1); </span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Father::<span class="built_in">Father</span>(<span class="type">char</span>*n1,<span class="type">int</span> a):<span class="built_in">name</span>(n1),<span class="built_in">age</span>(a)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;oh~ god!!!!:&quot;</span>&lt;&lt; name &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若空构造函数声明则必须实现。</p>
</blockquote>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数，在创建时执行</span></span><br><span class="line">        <span class="built_in">Father</span>(); </span><br><span class="line">	<span class="comment">// 析构函数，在删除时执行</span></span><br><span class="line">        ~<span class="built_in">Father</span>();</span><br><span class="line">&#125;;</span><br><span class="line">Father::<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;oh~ new！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">Father::~<span class="built_in">Father</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;oh~ delete！&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<ul>
<li>通过使用另一个同类型的对象来初始化新创建的对象。</li>
<li>复制对象把它作为参数传递给函数。</li>
<li>复制对象，并从函数返回这个对象。</li>
</ul>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。</p>
<blockquote>
<p>尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
</blockquote>
<p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <strong><code>friend</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">char</span>*name;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Father</span>(<span class="type">char</span>*n1,<span class="type">int</span> tag); </span><br><span class="line">        ~<span class="built_in">Father</span>(); </span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GN</span><span class="params">(Father *f)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">char</span>* <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GN</span><span class="params">(Father *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;f-&gt;name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;f-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Father *f1 = <span class="keyword">new</span> <span class="built_in">Father</span>(<span class="string">&quot;abc&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">GN</span>(f1);<span class="comment">// --&gt; abc 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为 <strong>基类</strong> ，新建的类称为 <strong>派生类</strong> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// eat() 函数</span></span><br><span class="line">    <span class="comment">// sleep() 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="comment">// bark() 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>基类的静态成员也可被继承，并且公用一处内存</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::count = <span class="number">0</span>;</span><br><span class="line">A::<span class="built_in">A</span>()&#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">cout&lt;&lt;A::count&lt;&lt;endl;<span class="comment">// -&gt; 1</span></span><br><span class="line">cout&lt;&lt;AA::count&lt;&lt;endl;<span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p><strong>多态</strong>按字面的意思就是多种形态。</p>
<p>以下是多态的几个关键点：</p>
<p> <strong>虚函数（Virtual Functions）</strong> ：</p>
<ul>
<li>在基类中声明一个函数为虚函数，使用关键字 <code>virtual</code>。</li>
<li>派生类可以重写（override）这个虚函数。</li>
<li>调用虚函数时，会根据对象的实际类型来决定调用哪个版本的函数。</li>
</ul>
<p> <strong>动态绑定（Dynamic Binding）</strong> ：</p>
<ul>
<li>也称为晚期绑定（Late Binding），在运行时确定函数调用的具体实现。</li>
<li>需要使用指向基类的指针或引用来调用虚函数，编译器在运行时根据对象的实际类型来决定调用哪个函数。</li>
</ul>
<p> <strong>纯虚函数（Pure Virtual Functions）</strong> ：</p>
<ul>
<li>一个包含纯虚函数的类被称为抽象类（Abstract Class），它不能被直接实例化。</li>
<li>纯虚函数没有函数体，声明时使用 <code>= 0</code>。</li>
<li>它强制派生类提供具体的实现。</li>
</ul>
<p> <strong>多态的实现机制</strong> ：</p>
<ul>
<li>虚函数表（V-Table）：C++运行时使用虚函数表来实现多态。每个包含虚函数的类都有一个虚函数表，表中存储了指向类中所有虚函数的指针。</li>
<li>虚函数指针（V-Ptr）：对象中包含一个指向该类虚函数表的指针。</li>
</ul>
<p> <strong>使用多态的优势</strong> ：</p>
<ul>
<li><strong>代码复用</strong> ：通过基类指针或引用，可以操作不同类型的派生类对象，实现代码的复用。</li>
<li><strong>扩展性</strong> ：新增派生类时，不需要修改依赖于基类的代码，只需要确保新类正确重写了虚函数。</li>
<li><strong>解耦</strong> ：多态允许程序设计更加模块化，降低类之间的耦合度。</li>
</ul>
<p> <strong>注意事项</strong> ：</p>
<ul>
<li>只有通过基类的指针或引用调用虚函数时，才会发生多态。</li>
<li>如果直接使用派生类的对象调用函数，那么调用的是派生类中的版本，而不是基类中的版本。</li>
<li>多态性需要运行时类型信息（RTTI），这可能会增加程序的开销。</li>
</ul>
<p>通过基类指针调用不同的派生类方法，展示了多态的动态绑定特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> L;</span><br><span class="line">        <span class="type">int</span> W;</span><br><span class="line">        <span class="built_in">A</span>();</span><br><span class="line">        <span class="built_in">A</span>(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">A::<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> l, <span class="type">int</span> w):<span class="built_in">L</span>(l), <span class="built_in">W</span>(w)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">A::area</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> L+W;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Aa</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> L*W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Aa</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ab</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> L/W;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Ab</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 委托基类构造派生类</span></span><br><span class="line">Aa::<span class="built_in">Aa</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a,b) &#123;&#125;</span><br><span class="line">Ab::<span class="built_in">Ab</span>(<span class="type">int</span> a,<span class="type">int</span> b):<span class="built_in">A</span>(a,b) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="literal">nullptr</span>;</span><br><span class="line">    Aa aa&#123;<span class="number">10</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    Ab bb&#123;<span class="number">10</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    a = &amp;aa;<span class="comment">// 基类指针更换绑定，体现多态</span></span><br><span class="line">    cout&lt;&lt;a-&gt;<span class="built_in">area</span>()&lt;&lt;endl;</span><br><span class="line">    a = &amp;bb;<span class="comment">// 基类指针更换绑定，体现多态</span></span><br><span class="line">    cout&lt;&lt;a-&gt;<span class="built_in">area</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>纯虚函数是没有实现的虚函数，在基类中用 <strong><code>= 0</code></strong> 来声明。</p>
<p>纯虚函数表示基类定义了一个接口，但具体实现由派生类负责。</p>
<p>纯虚函数使得基类变为抽象类（abstract class），无法实例化。</p>
<p> <strong>特点：</strong></p>
<ul>
<li><strong>必须在基类中声明为 <code>= 0</code></strong> ，表示没有实现，子类必须重写。</li>
<li><strong>抽象类</strong> ：包含纯虚函数的类不能直接实例化，必须通过派生类实现所有纯虚函数才能创建对象。</li>
<li><strong>接口定义</strong> ：纯虚函数通常用于定义接口，让派生类实现具体行为。</li>
</ul>
<h3 id="虚函数与纯虚函数的对比"><a href="#虚函数与纯虚函数的对比" class="headerlink" title="虚函数与纯虚函数的对比"></a>虚函数与纯虚函数的对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>虚函数（Virtual Function）</th>
<th>纯虚函数（Pure Virtual Function）</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>基类中使用 <code>virtual</code> 声明，可以有实现</td>
<td>基类中使用 <code>= 0</code> 声明，无实现</td>
</tr>
<tr>
<td>子类重写</td>
<td>子类可以选择重写</td>
<td>子类必须实现</td>
</tr>
<tr>
<td>抽象性</td>
<td>可以实例化类</td>
<td>使类变为抽象类，无法实例化</td>
</tr>
<tr>
<td>用途</td>
<td>提供默认行为，允许子类重写</td>
<td>定义接口，强制子类实现具体行为</td>
</tr>
</tbody></table>
<h1 id="重载运算符和重载函数"><a href="#重载运算符和重载函数" class="headerlink" title="重载运算符和重载函数"></a>重载运算符和重载函数</h1><p>C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">setW</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">	<span class="comment">// 重载 + 声明</span></span><br><span class="line">        A <span class="keyword">operator</span>+(<span class="type">const</span> A &amp;a); </span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">printInf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::setW</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;w = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重载 + 实现</span></span><br><span class="line">A A::<span class="keyword">operator</span>+(<span class="type">const</span> A &amp;a)&#123;</span><br><span class="line">    A tem;</span><br><span class="line">    tem.w = <span class="keyword">this</span>-&gt;w + a.w;</span><br><span class="line">    <span class="keyword">return</span> tem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::printInf</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="keyword">this</span>-&gt;w&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    a<span class="number">1.</span><span class="built_in">setW</span>(<span class="number">100</span>);</span><br><span class="line">    a<span class="number">2.</span><span class="built_in">setW</span>(<span class="number">1000</span>);</span><br><span class="line">    A a3 = a1+a2;</span><br><span class="line">    a<span class="number">3.</span><span class="built_in">printInf</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符&#x2F;不可重载运算符"></a>可重载运算符&#x2F;不可重载运算符</h2><p>下面是可重载的运算符列表：</p>
<table>
<thead>
<tr>
<th>运算符列表</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>双目算术运算符</td>
<td>+ (加)，-(减)，*(乘)，&#x2F;(除)，% (取模)</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&#x3D;&#x3D;(等于)，!&#x3D; (不等于)，&lt; (小于)，&gt; (大于)，&lt;&#x3D;(小于等于)，&gt;&#x3D;(大于等于)</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>(逻辑或)，(逻辑与)，(逻辑非)</td>
</tr>
<tr>
<td>单目运算符</td>
<td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td>
</tr>
<tr>
<td>自增自减运算符</td>
<td>++(自增)，–(自减)</td>
</tr>
<tr>
<td>位运算符</td>
<td>(按位或)， (按位与)，(按位取反)，(按位异或),， (左移)，(右移)</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>&#x3D;, +&#x3D;, -&#x3D;, *&#x3D;, &#x2F;&#x3D; , % &#x3D; , &amp;&#x3D;,</td>
</tr>
<tr>
<td>空间申请与释放</td>
<td>new, delete, new[ ] , delete[]</td>
</tr>
<tr>
<td>其他运算符</td>
<td><strong>()</strong>(函数调用)，<strong>-&gt;</strong>(成员访问)，<strong>,</strong>(逗号)，<strong>[]</strong>(下标)</td>
</tr>
</tbody></table>
<p>下面是不可重载的运算符列表：</p>
<ul>
<li><strong>.</strong>：成员访问运算符</li>
<li><strong>.</strong>*, -&gt; *：成员指针访问运算符</li>
<li><strong>::</strong>：域运算符</li>
<li><strong>sizeof</strong>：长度运算符</li>
<li><strong>?:</strong>：条件运算符</li>
<li><strong>#</strong>： 预处理符号</li>
</ul>
<h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// []      // 沒有定义任何变量。使用未定义变量会引发错误。</span></span><br><span class="line"><span class="comment">// [x, &amp;y] // x以传值方式传入（默认），y以引用方式传入。</span></span><br><span class="line"><span class="comment">// [&amp;]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。</span></span><br><span class="line"><span class="comment">// [=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。</span></span><br><span class="line"><span class="comment">// [&amp;, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。</span></span><br><span class="line"><span class="comment">// [=, &amp;z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。</span></span><br><span class="line"><span class="keyword">auto</span> func = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123; <span class="type">int</span> z = x + y; <span class="keyword">return</span> z + x; &#125;;<span class="comment">//z = 1+2,ret=3+1</span></span><br></pre></td></tr></table></figure>

<h1 id="内联函数inline"><a href="#内联函数inline" class="headerlink" title="内联函数inline"></a>内联函数inline</h1><p> 引入内联函数的目的是为了解决程序中函数调用的效率问题，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：</p>
<ul>
<li>1.在内联函数内不允许使用循环语句和开关语句；</li>
<li>2.内联函数的定义必须出现在内联函数第一次调用之前；</li>
<li>3.类结构中所在的类说明内部定义的函数是内联函数。</li>
</ul>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 迭代访问</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it!=vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 范围访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> ele : vec)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;ele&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除第index+1个元素</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()+index);</span><br><span class="line"><span class="comment">// 清除</span></span><br><span class="line">vec.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中复杂用法小计</title>
    <url>/2025/03/03/noteC-1/</url>
    <content><![CDATA[<h1 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h1><p>例：二维数组分配。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **array;</span><br><span class="line"><span class="comment">// 假定数组第一维长度为 m， 第二维长度为 n</span></span><br><span class="line"><span class="comment">// 动态分配空间</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="type">int</span> *[m];</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    array[i] = <span class="keyword">new</span> <span class="type">int</span> [n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] array[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> [] array;</span><br></pre></td></tr></table></figure>

<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><ul>
<li>shared_ptr：共享一个对象</li>
<li>unique_ptr：独占一个对象</li>
<li>weak_ptr：</li>
</ul>
<blockquote>
<p>shared_ptr常用 <code>std::make_shared &lt;&gt; ()</code>来创建</p>
</blockquote>
<p>shared_ptr使用引用计数来判断是否销毁指针空间，但也存在内存泄漏问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;B&gt; pointer;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; pointer;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line">    a-&gt;pointer = b;</span><br><span class="line">    b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露。</p>
<p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。弱引用不会引起引用计数增加。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
